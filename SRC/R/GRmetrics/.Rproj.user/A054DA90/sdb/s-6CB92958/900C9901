{
    "contents" : ".GRcalculate = function(inputData, groupingVariables, cap = F, case = \"A\") {\n  log2nn = with(inputData, log2(cell_count/cell_count__time0))\n  log2nn_ctrl = with(inputData, log2(cell_count__ctrl/cell_count__time0))\n  GR = 2^(log2nn/log2nn_ctrl) - 1\n  input_edited = inputData\n  input_edited$log10_concentration = log10(input_edited$concentration)\n  input_edited$GR = GR\n  tmp<-input_edited[,groupingVariables, drop = F]\n  experimentNew = (apply(tmp,1, function(x) (paste(x,collapse=\" \"))))\n  if(cap == T) {\n    input_edited$GR[input_edited$GR > 1] = 1\n    input_edited$GR[input_edited$GR < -1] = -1\n  }\n  if(length(groupingVariables) > 0) {\n    input_edited$experiment = as.factor(experimentNew)\n  } else {\n    input_edited$experiment = as.factor(\"All Data\")\n  }\n  return(input_edited)\n}\n\n.GRlogisticFit = function(inputData, groupingVariables, force = F, cap = F) {\n  experiments = levels(inputData$experiment)\n  parameters = matrix(data = NA, ncol = 3, nrow = length(experiments))\n  parameters = as.data.frame(parameters)\n  colnames(parameters) = c('Hill','GRinf','GEC50')\n  if(length(groupingVariables) > 0) {\n    metadata = matrix(data = NA, ncol = length(groupingVariables), nrow = length(experiments))\n    metadata = as.data.frame(metadata)\n    colnames(metadata) = groupingVariables\n  } else {\n    metadata = NULL\n  }\n  pval = NULL\n  GRmax = NULL\n  GR_mean = NULL\n  AOC = NULL\n  R_square = NULL\n  for(i in 1:length(experiments)) {\n    # print(i)\n    data_exp = inputData[inputData$experiment == experiments[i], ]\n    concs = sort(unique(data_exp$concentration))\n    l = length(concs)\n    max_concs = data_exp[data_exp$concentration %in% concs[c(l,l-1)],]\n    GRmax[i] = min(max_concs$GR, na.rm = T)\n    #     metadata[i,] = data_exp[1,1:5]\n    if(!is.null(metadata)) {\n      metadata[i,] = data_exp[1,groupingVariables, drop = F]\n    }\n    GR_mean[i] = mean(data_exp$GR, na.rm = T)\n    #===== constrained fit ============\n    c = unique(data_exp$concentration)\n    priors = c(2, 0.1, median(c))\n    lower = c(.1, -1, min(c)*1e-2)\n    upper = c(5, 1, max(c)*1e2)\n    if(dim(data_exp)[1] > 1) {\n      controls = drc::drmc()\n      controls$relTol = 1e-06 #set to match MATLAB code\n      controls$errorm = F\n      controls$noMessage = T\n      controls$rmNA = T\n      output_model_new = try(drc::drm(GR~concentration, experiment, data=data_exp, fct=drc::LL.3u(names=c('Hill','GRinf','GEC50')), start = priors, lowerl = lower, upperl = upper, control = controls, na.action = na.omit))\n      if(class(output_model_new)!=\"try-error\") {\n        parameters[i,] = c(as.numeric(coef(output_model_new)))\n        # F-test for the significance of the sigmoidal fit\n        Npara = 3 # N of parameters in the growth curve\n        Npara_flat = 1 # F-test for the models\n        RSS2 = sum(residuals(output_model_new)^2, na.rm = T)\n        RSS1 = sum((data_exp$GR - mean(data_exp$GR, na.rm = T))^2, na.rm = T)\n        df1 = (Npara - Npara_flat)\n        df2 = (length(na.omit(data_exp$GR)) - Npara + 1)\n        f_value = ((RSS1-RSS2)/df1)/(RSS2/df2)\n        f_pval = pf(f_value, df1, df2, lower.tail = F)\n        pval[i] = f_pval\n        R_square[i] = 1 - RSS2/RSS1\n      }\n    }\n    #==================================\n\n    # Trapezoid rule for integration of GR_AOC\n    GRavg = NULL\n    for(j in 1:length(concs)) {\n      data_trapz = data_exp[data_exp$concentration == concs[j],]\n      GRavg[j] = mean(data_trapz$GR, na.rm = T)\n    }\n    AOC[i] = sum((1 - (GRavg[1:(length(GRavg)-1)]+GRavg[2:length(GRavg)])/2)*diff(log10(concs), lag = 1), na.rm = T)/(log10(concs[length(concs)]) - log10(concs[1]))\n  }\n\n  # Calculate GR50 from parameters\n  parameters$GR50 = with(parameters, GEC50*((1-GRinf)/(0.5-GRinf) - 1)^(1/Hill))\n  parameters$GRmax = GRmax\n  parameters$GR_AOC = AOC\n  parameters$r2 = R_square\n  if(is.null(pval)) {pval = NA}\n  parameters$pval = pval\n  # Re-order rows to match reference_output\n  parameters$experiment = experiments\n  # Threshold for F-test pval\n  pcutoff = ifelse(force == F, .05 , 1)\n  for(i in 1:dim(parameters)[1]) {\n    if(!is.na(parameters$pval[i])) {\n      parameters$fit[i] = ifelse(parameters$pval[i] >= pcutoff | is.na(parameters$GEC50[i]), \"flat\",\"sigmoid\")\n    } else {\n      parameters$fit[i] = ifelse(is.na(parameters$GEC50[i]), \"flat\", \"sigmoid\")\n    }\n  }\n  # changed to above code to deal with NAs\n  #parameters$fit = with(parameters, ifelse(pval >= pcutoff | is.na(GEC50), \"flat\",\"sigmoid\"))\n  # Add specified values for flat fits: GEC50 = 0, Hill = 0.01 and GR50 = +/- Inf\n  parameters$flat_fit = GR_mean\n  for(i in 1:dim(parameters)[1]) {\n    if(parameters$fit[i] == \"flat\") {\n      parameters$GEC50[i] = 0\n      parameters$Hill[i] = 0.01\n      parameters$GR50[i] = ifelse(parameters$flat_fit[i] > .5, Inf, -Inf)\n      parameters$GRinf[i] = parameters$flat_fit[i]\n    }\n  }\n  # Add GR50 = +/-Inf for any curves that don't reach GR = 0.5\n  for(i in 1:dim(parameters)[1]) {\n    if(is.na(parameters$GR50[i])) {\n      parameters$GR50[i] = ifelse(parameters$flat_fit[i] > .5, Inf, -Inf)\n    }\n  }\n  for(i in 1:dim(parameters)[1]) {\n    if(parameters$fit[i] == \"sigmoid\") {\n      parameters$flat_fit[i] = NA\n    }\n  }\n  parameters = parameters[,c('GR50','GRmax','GR_AOC','GEC50','GRinf','Hill', 'r2','pval','experiment', 'fit','flat_fit')]\n  if(!is.null(metadata)) {\n    parameters = cbind(metadata, parameters)\n  }\n  return(parameters)\n}\n\n.GRlogistic_3u = function(c){GRinf + (1 - GRinf)/(1 + (c/GEC50)^Hill)}\n\n.trim_mean = function(x, percent) {\n  x = x[!is.na(x)]\n  n = length(x)\n  k = n*(percent/100)/2\n  # round down if k is half an integer\n  if(round(k) != k & round(k*2) == k*2) {\n    lo = floor(k) + 1\n    hi = n - lo + 1\n  } else {\n    lo = round(k) + 1\n    hi = n - lo + 1\n  }\n  x = sort(x)[lo:hi]\n  return(mean(x))\n}\n\n.convert = function(inputData, case, concentration = 'concentration', cell_count = 'cell_count', time = 'time', cell_count__time0 = 'cell_count__time0', cell_count__ctrl = 'cell_count__ctrl') {\n  if(case == \"A\") {\n    if(length(intersect(colnames(inputData), c('concentration', 'cell_count', 'cell_count__ctrl', 'cell_count__time0'))) == 4) {\n      return(inputData)\n    } else {\n      inputData$concentration = inputData[[concentration]]\n      inputData$cell_count = inputData[[cell_count]]\n      inputData$cell_count__ctrl = inputData[[cell_count__ctrl]]\n      inputData$cell_count__time0 = inputData[[cell_count__time0]]\n      delete_cols = setdiff(c(concentration, cell_count, cell_count__time0, cell_count__ctrl), c('concentration', 'cell_count', 'cell_count__ctrl', 'cell_count__time0'))\n      delete_col_nums = which(colnames(inputData) %in% delete_cols)\n      inputData = inputData[,-delete_col_nums]\n      return(inputData)\n    }\n  } else if(case == \"C\") {\n    delete_cols = which(colnames(inputData) %in% c(concentration, cell_count))\n    keys = colnames(inputData)[-delete_cols]\n    time0 = inputData[inputData[[time]] == 0, c(keys, cell_count)]\n    ctrl = inputData[inputData[[concentration]] == 0 & inputData[[time]] > 0, c(keys, cell_count)]\n    data = inputData[inputData[[concentration]] != 0 & inputData[[time]] > 0, ]\n    time0_keys = NULL\n    ctrl_keys = NULL\n    for(i in 1:length(keys)) {\n      time0_keys[i] = length(intersect(time0[[ keys[i] ]], data[[ keys[i] ]])) > 0\n      ctrl_keys[i] = length(intersect(ctrl[[ keys[i] ]], data[[ keys[i] ]])) > 0\n    }\n    ctrl_keys = keys[ctrl_keys]\n    time0_keys = keys[time0_keys]\n\n    temp = ctrl[, ctrl_keys]\n    ctrl$key = apply(temp, 1, function(x) paste(x, collapse = ' '))\n\n    temp = time0[, time0_keys]\n    time0$key = apply(temp, 1, function(x) paste(x, collapse = ' '))\n\n    temp = data[, ctrl_keys]\n    data$key_ctrl = apply(temp, 1, function(x) paste(x, collapse = ' '))\n\n    temp = data[, time0_keys]\n    data$key_time0 = apply(temp, 1, function(x) paste(x, collapse = ' '))\n\n    data$cell_count__ctrl = NA\n    data$cell_count__time0 = NA\n    for(key in unique(ctrl$key)) {\n      trimmed_mean = .trim_mean(ctrl[ctrl$key == key,][[cell_count]], 50)\n      data[data$key_ctrl == key, 'cell_count__ctrl'] = trimmed_mean\n    }\n\n    for(key in unique(time0$key)) {\n      trimmed_mean = .trim_mean(time0[time0$key == key,][[cell_count]], 50)\n      data[data$key_time0 == key, 'cell_count__time0'] = trimmed_mean\n    }\n\n    delete_cols = which(colnames(data) %in% c('key_ctrl', 'key_time0'))\n    data = data[, -delete_cols]\n\n    row.names(data) = 1:dim(data)[1]\n    inputData = data\n    if(length(intersect(colnames(inputData), c('concentration', 'cell_count', 'time'))) == 3) {\n      return(inputData)\n    } else {\n      inputData$concentration = inputData[[concentration]]\n      inputData$cell_count = inputData[[cell_count]]\n      inputData$time = inputData[[time]]\n      delete_cols = setdiff(c(concentration, cell_count, time), c('concentration', 'cell_count', 'time'))\n      delete_col_nums = which(colnames(inputData) %in% delete_cols)\n      inputData = inputData[,-delete_col_nums]\n      return(inputData)\n    }\n  }\n}\n\n#' Extract GR parameters from a dataset\n#'\n#' This function takes in a dataset with information about concentration,\n#' cell counts over time, and additional grouping variables for a dose-response assay\n#' and calculates growth-rate inhibition (GR) metrics for each experiment in\n#' the dataset. The data must be in a specific format: either that specified\n#' by case \"A\" or case \"C\" described here\n#' \\url{https://github.com/sorgerlab/gr50_tools/blob/master/README.md} and in\n#' the details below, although the column names of the key variables\n#' (concentration, cell_count, etc.) can be specified in the command.\n#'\n#' @param inputData a data table in one of the specified formats (Case A or\n#' Case C). See details below or\n#' \\url{https://github.com/sorgerlab/gr50_tools/blob/master/README.md}\n#' @param groupingVariables a vector of column names from inputData. All of the\n#'  columns in inputData except for those identified here will be averaged over.\n#' @param GRtable a character string (\"param\", \"GR\", or \"both\") identifying\n#'  whether to return, respectively, only the table of parameters, only the\n#'  table of GR values, or both tables. Default is \"both\".\n#' @param force a logical value indicating whether to attempt to \"force\" a\n#' sigmoidal fit, i.e. whether to allow fits with F-test p-values greater\n#' than .05\n#' @param cap a logical value indicating whether to cap GR values in between\n#'  -1 and 1 (the range of the GR dose-response curve). If true, all GR values\n#'  greater than 1 will be set to 1 and all values less than -1 will be set\n#'  to -1.\n#' @param case either \"A\" or \"C\", indicating the format of the input data. See\n#' here \\url{https://github.com/sorgerlab/gr50_tools/blob/master/README.md}\n#' or details below for descriptions of these formats.\n#' @param concentration (Case A and Case C) the name of the column with\n#' concentration values (not log transformed) of the perturbagen on which\n#' dose-response curves will be evaluated\n#' @param cell_count (Case A and Case C) the name of the column with the\n#' measure of cell number (or a surrogate of cell number such as CellTiter-Glo®\n#' staining) after treatment\n#' @param time (Case C) the name of the column with the time at which a cell\n#' count is observed\n#' @param cell_count__time0 (Case A) the name of the column with Time 0 cell\n#' counts - the measure of cell number in untreated wells grown in parallel\n#' until the time of treatment\n#' @param cell_count__ctrl (Case A) the name of the column with the Control\n#' cell count - the measure of cell number in control (e.g. untreated or\n#' DMSO-treated) wells from the same plate\n#' @return By default, a list of three elements is returned: 1) a data table of\n#' the original data, converted to the style of Case A, with GR values for each\n#' experiment 2) a data table of GR metrics parameters (GR50, GRmax, etc.) as\n#' well as goodness of fit measures. 3) the vector of grouping variables (this\n#' is used for other functions such as \\code{\\link{GRdrawDRC}}). If GRtable is\n#' equal to \"GR\", then only (1) and (3) are returned. If GRtable is set to\n#' \"param\", then only (2) and (3) are returned.\n#' @author Nicholas Clark\n#' @details\n#' Calculation of GR values is performed by the function \\code{.GRcalculate}\n#' according to the \"Online Methods\" section of Hafner and Niepel et al.\n#' (\\url{http://dx.doi.org/10.1038/nmeth.3853}).\n#'\n#' The fitting of the logistic curve is performed by the \\code{.GRlogisticFit}\n#' function, which calls the \\code{drm} function from the \\code{drc} package\n#' to solve for the curve parameters. The GR curve fit function is\n#' given by f(c) = GRinf + (1 - GRinf)/(1 + (c/GEC50)^Hill) where c is\n#' concentration. The fit is performed under following constraints: Hill slope\n#' in [.1, 5], GRinf in [-1, 1], and GEC50 in [min(c)*1e-2, max(c)*1e2] (c is\n#' concentration). The initial conditions for the fitting algorithm are Hill\n#' slope = 2, GRinf = 0.1 and GEC50 = median(c).\n#'\n#' The parameters of the curve for each experiment are fitted separately. An\n#' F-test is used to compare the sigmoidal fit to a flat line fit. If the\n#' p-value of the F-test is less than .05, the sigmoidal fit is accepted. If\n#' the p-value is greater than or equal to .05, a flat horizontal line fit is\n#' given, with y equal to the mean of the GR values. In the parameters data\n#' table, for each flat fit, GEC50 is set to 0, Hill is set to 0.01, GRinf is\n#' set to the y value of the flat fit (the mean of the GR values), and GR50 is\n#' set to +/-Inf depending on whether GRinf is greater or less than .5.\n#'\n#' @note\n#' To see the underlying code, use (\\code{getAnywhere(.GRlogistic_3u)}),\n#' (\\code{getAnywhere(.GRcalculate)}), and (\\code{getAnywhere(.GRlogisticFit)})\n#' @seealso See \\code{\\link{drm}} for the general logistic fit function that\n#' solves for the parameters GRinf, GEC50, and Hill slope. See \\code{\\link{drmc}} for\n#' options of this function. Use the functions \\code{\\link{GRdrawDRC}},\n#' \\code{\\link{GRbox}}, and \\code{\\link{GRscatter}} to create visualizations\n#' using the output from this function. For online GR calculator and browser, see\n#' \\url{http://www.grcalculator.org}.\n#' @references Hafner, M., Niepel, M. Chung, M. and Sorger, P.K., \"Growth Rate Inhibition Metrics Correct For Confounders In Measuring Sensitivity To Cancer Drugs\". \\emph{Nature Methods} 13.6 (2016): 521-527.\n#' \\link{http://dx.doi.org/10.1038/nmeth.3853}\n#' @examples\n#' # Load Case A (example 1) input\n#' data(\"inputCaseA\")\n#' head(inputCaseA)\n#' # Run GRfit function with case = \"A\"\n#' output1 = GRfit(inputData = inputCaseA, groupingVariables = c('cell_line','agent', 'perturbation','replicate', 'time'))\n#' # See parameter table\n#' head(output1$parameter_table)\n#' # See GR values table\n#' head(output1$gr_table)\n#' # Load Case C (example 4) input\n#' # Same data, different format\n#' data(\"inputCaseC\")\n#' head(inputCaseC)\n#' output4 = GRfit(inputData = inputCaseC, groupingVariables = c('cell_line','agent', 'perturbation','replicate', 'time'), case = \"C\")\n#'\n#' @export\n\nGRfit = function(inputData, groupingVariables, GRtable = 'both', force = F, cap = F, case = \"A\", concentration = 'concentration', cell_count = 'cell_count', time = 'time', cell_count__time0 = 'cell_count__time0', cell_count__ctrl = 'cell_count__ctrl') {\n  inputData = .convert(inputData, case, concentration, cell_count, time, cell_count__time0, cell_count__ctrl)\n  gr_table = .GRcalculate(inputData, groupingVariables, cap, case)\n  if(GRtable == 'GR') {\n    returnList = list(gr_table, groupingVariables)\n    names(returnList) = c(gr_table, groupingVariables)\n    class(returnList) = 'GRfit'\n    return(returnList)\n  }\n  parameter_table = .GRlogisticFit(gr_table, groupingVariables, force, cap)\n  if(GRtable == 'param'){\n    returnList = list(parameter_table, groupingVariables)\n    names(returnList) = c('parameter_table', 'groupingVariables')\n    class(returnList) = 'GRfit'\n    return(returnList)\n  } else if(GRtable == 'both') {\n    returnList = list(gr_table,parameter_table, groupingVariables)\n    names(returnList) = c('gr_table', 'parameter_table', 'groupingVariables')\n    class(returnList) = 'GRfit'\n    return(returnList)\n  }\n}\n\n",
    "created" : 1466014176448.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1756638236",
    "id" : "900C9901",
    "lastKnownWriteTime" : 1466182775,
    "path" : "~/Desktop/Git/Public Github/GRmetrics/R/GRfunctions.R",
    "project_path" : "R/GRfunctions.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "type" : "r_source"
}